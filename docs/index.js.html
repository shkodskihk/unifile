<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Unifile.html">Unifile</a><ul class='methods'><li data-type='method'><a href="Unifile.html#batch">batch</a></li><li data-type='method'><a href="Unifile.html#clearAccessToken">clearAccessToken</a></li><li data-type='method'><a href="Unifile.html#createReadStream">createReadStream</a></li><li data-type='method'><a href="Unifile.html#createWriteStream">createWriteStream</a></li><li data-type='method'><a href="Unifile.html#getAuthorizeURL">getAuthorizeURL</a></li><li data-type='method'><a href="Unifile.html#getInfos">getInfos</a></li><li data-type='method'><a href="Unifile.html#listConnectors">listConnectors</a></li><li data-type='method'><a href="Unifile.html#login">login</a></li><li data-type='method'><a href="Unifile.html#mkdir">mkdir</a></li><li data-type='method'><a href="Unifile.html#readdir">readdir</a></li><li data-type='method'><a href="Unifile.html#readFile">readFile</a></li><li data-type='method'><a href="Unifile.html#rename">rename</a></li><li data-type='method'><a href="Unifile.html#rmdir">rmdir</a></li><li data-type='method'><a href="Unifile.html#setAccessToken">setAccessToken</a></li><li data-type='method'><a href="Unifile.html#setBasicAuth">setBasicAuth</a></li><li data-type='method'><a href="Unifile.html#unlink">unlink</a></li><li data-type='method'><a href="Unifile.html#use">use</a></li><li data-type='method'><a href="Unifile.html#writeFile">writeFile</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Promise.html">Promise</a></li><li><a href="external-ReadableStream.html">ReadableStream</a></li><li><a href="external-WritableStream.html">WritableStream</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @namespace Unifile */
'use strict';

/**
 * The built-in Node.js WritableStream class
 * @external WritableStream
 * @see https://nodejs.org/api/stream.html#stream_writable_streams
 */

/**
 * The built-in Node.js ReadableStream class
 * @external ReadableStream
 * @see https://nodejs.org/api/stream.html#stream_readable_streams
 */

/**
 * Bluebird Promise class
 * @external Promise
 * @see http://bluebirdjs.com/docs/api-reference.html
 */

/**
 * Representation of a connector infos
 * @typedef {Object} ConnectorInfos
 * @property {string} name
 * @property {string} displayName
 * @property {string} icon
 * @property {string} description
 * @property {boolean} isLoggedIn
 * @property {boolean} isOAuth
 * @property {string} username
 */

/**
 * Credentials of a service
 * @typedef {Object} Credentials
 *
 * For non-OAuth services
 * @property {string} [host] - URL to the service
 * @property {string} [port] - Port the auth service is listening to
 * @property {string} [user] - Username for the service
 * @property {string} [password] - Password for the service
 *
 * For OAuth services
 * @property {string} [code] - OAuth code for the service
 * @property {string} [state] - OAuth state for the service
 */

/**
 * Representation of a file
 * @typedef {Object} FileInfos
 * @property {string} name - Name of the file
 * @property {number} size - Size of the file in bytes
 * @property {string} modified - ISO string representation of the date from last modification
 * @property {boolean} isDir - Wether this is a directory or not
 * @property {string} mime - MIME type of this file
 */

/**
 * Unifile class
 * This will use connectors to distant services to manipulate the files.
 * An empty instance of Unifile cannot connect to any service. You must first call the use() function
 * to register a connector.
 */
class Unifile {

  /**
   * Create a new instance of Unifile.
   * This will regroup all the connectors you decided to use.
   * @constructor
   */
  constructor() {
    this.connectors = new Map();
  }

  /**
   * Adds a new connector into Unifile.
   * Once a connector has been register with this function, it can be used with all the commands.
   * @param {Connector} connector - A connector implementing all of Unifile functions
   */
  use(connector) {
    if(!connector) throw new Error('Connector cannot be undefined');
    if(!connector.name) throw new Error('Connector must have a name');
    this.connectors.set(connector.name.toLowerCase(), connector);
  }

  // Infos commands

  /**
   * Get all the info you need about a connector
   * @param {string} connectorName - Name of the connector
   * @return {ConnectorInfos} all the infos about this connector
   */
  getInfos(connectorName) {
    return this.callMethod(connectorName, null, 'getInfos');
  }

  /**
   * List all the connectors currently used in this instance of Unifile
   * @return {string[]} an array of connectors names
   */
  listConnectors() {
    return Array.from(this.connectors.keys());
  }

  // Auth commands

  /**
   * Log a connector in a distant service.
   * This must be called before any access to the service or an error will be thrown.
   * The result of a successful login attempt will be saved in the session.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {Credentials} credentials - Service credentials (user/password or OAuth code)
   * @return {external:Promise&lt;string|null>} a promise of OAuth token if the service uses it or null
   */
  login(session, connectorName, credentials) {
    return this.callMethod(connectorName, session, 'login', credentials);
  }

  /**
   * Log in a connector with basic auth (username/password)
   * This must be called before any access to the service or an error will be thrown.
   * The result of a successful login attempt will be saved in the session.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} username - Username for the service
   * @param {string} password - Password for the service
   * @return {external:Promise&lt;null>} a successful promise if the credentials were correct
   */
  setBasicAuth(session, connectorName, username, password) {
    return this.callMethod(connectorName, session, 'setBasicAuth', username, password);
  }

  /**
   * Log a connector by directly using a OAuth token.
   * You don't have to call the method if you use the login() method. This is only in the case
   * you got a token from anothe source (CLI, app,...)
   * This must be called before any access to the service or an error will be thrown.
   * The result of a successful login attempt will be saved in the session.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} token - Service access token generated by OAuth
   * @return {external:Promise&lt;string|null>} a promise of OAuth token if the service uses it or null
   */
  setAccessToken(session, connectorName, token) {
    return this.callMethod(connectorName, session, 'setAccessToken', token);
  }

  /**
   * Log out from a connector.
   * After that you won't be able to make any request until you log in again.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @return {external:Promise&lt;null>} an empty promise.
   */
  clearAccessToken(session, connectorName) {
    return this.callMethod(connectorName, session, 'clearAccessToken');
  }

  /**
   * Get the URL of the authorization endpoint for an OAuth service.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @return {external:Promise&lt;string>} a promise of the authorization URL
   */
  getAuthorizeURL(session, connectorName) {
    return this.callMethod(connectorName, session, 'getAuthorizeURL');
  }

  // Filesystem commands

  /**
   * Reads the content of a directory.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the directory to read. Must be relative to the root of the service.
   * @return {external:Promise&lt;FileInfos[]>} a promise of an array of FileInfos
   * @see {@link FileInfos} to get the properties of the return objects
   */
  readdir(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'readdir', path);
  }

  /**
   * Create a directory.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the directory to create. Must be relative to the root of the service.
   * @return {external:Promise&lt;null>} an empty promise
   */
  mkdir(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'mkdir', path);
  }

  /**
   * Write content to a file.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the file to write. Must be relative to the root of the service.
   * @param {string} content - Content to write into the file
   * @return {external:Promise&lt;null>} an empty promise.
   */
  writeFile(session, connectorName, path, content) {
    return this.callMethod(connectorName, session, 'writeFile', path, content);
  }

  /**
   * Create a write stream to a file.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the file to write. Must be relative to the root of the service.
   * @return {external:WritableStream} a writable stream into the file
   */
  createWriteStream(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'createWriteStream', path);
  }

  /**
   * Read the content of the file.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the file to read. Must be relative to the root of the service.
   * @return {external:Promise&lt;string>} a promise of the content of the file
   */
  readFile(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'readFile', path);
  }

  /**
   * Create a read stream to a file.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the file to read. Must be relative to the root of the service.
   * @return {external:ReadableStream} a readable stream from the file
   */
  createReadStream(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'createReadStream', path);
  }

  /**
   * Rename a file.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} source - Path to the file to rename. Must be relative to the root of the service.
   * @param {string} destination - New path to give to the file. Must be relative to the root of the service.
   * @return {external:Promise&lt;null>} an empty promise.
   */
  rename(session, connectorName, source, destination) {
    return this.callMethod(connectorName, session, 'rename', source, destination);
  }

  /**
   * Unlink (delete) a file.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the file to delete. Must be relative to the root of the service.
   * @return {external:Promise&lt;null>} an empty promise.
   */
  unlink(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'unlink', path);
  }

  /**
   * Remove a directory.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {string} path - Path of the directory to delete. Must be relative to the root of the service.
   * @return {external:Promise&lt;null>} an empty promise.
   */
  rmdir(session, connectorName, path) {
    return this.callMethod(connectorName, session, 'rmdir', path);
  }

  // Batch operation
  /**
   * Execute batch operation.
   * Available actions are UNLINK, RMDIR, RENAME, MKDIR and WRITEFILE.
   * @param {Object} session - Object where session data will be stored
   * @param {string} connectorName - Name of the connector
   * @param {Object[]} actions - Array of actions to execute in this batch.
   * @param {string} actions[].name - Name of this action.
   * @param {string} actions[].path - Path parameter for this action.
   * @param {string} [actions[].destination] - Destination parameter for this action.
   * @param {string} [actions[].content] - Content parameter for this action.
   * @param {string} [message] - Message to describe this batch
   * @return {external:Promise&lt;null>} an empty promise.
   */
  batch(session, connectorName, actions, message) {
    return this.callMethod(connectorName, session, 'batch', actions, message);
  }

  // Privates

  callMethod(connectorName, session, methodName, ...params) {
    if(!connectorName) throw new Error('You should specify a connector name!');
    const name = connectorName.toLowerCase();
    if(!this.connectors.has(name)) throw new Error(`Unknown connector: ${connectorName}`);
    const connector = this.connectors.get(name);
    if(!(methodName in connector)) throw new Error(`This connector does not implement ${methodName}()`);
    if(!session) session = {name: {}};
    else if(!(name in session)) session[name] = {};
    return connector[methodName](session[name], ...params);
  }
}

module.exports = Unifile;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Sep 16 2016 18:18:53 GMT+0200 (CEST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
